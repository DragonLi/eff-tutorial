\section{Introduction}

Pure functional languages with dependent types such as \Idris{}
(\url{http://idris-lang.org/})
support reasoning about programs directly in the type system, promising that we
can \emph{know} a program will run correctly (i.e. according to the
specification in its type) simply because it compiles. Realistically, though,
things are not so simple: programs have to interact with the outside world,
with user input, input from a network, mutable state, and so on. In this
tutorial I will introduce the \effects{} library, which is included with
the \Idris{} distribution and supports programming and reasoning with
side-effecting programs, supporting mutable state, interaction with the
outside world, exceptions, and verified resource management.

This tutorial assumes familiarity with pure programming in \Idris{}, as
described in Sections 1--6 of the main
tutorial~\cite{idris-tutorial}\footnote{You do not, however, need to know what
a monad is. A correctness property of this tutorial is that the word ``monad''
should appear exactly twice, both in this footnote.}. The examples are
tested with \Idris{} version \version{}.

Consider, for example, the following introductory function which illustrates
the kind of properties which can be expressed in the type system:

\begin{code}
vadd : Vect n Int -> Vect n Int -> Vect n Int
vadd []        []        = []
vadd (x :: xs) (y :: ys) = x + y :: vadd xs ys
\end{code}

This function adds corresponding elements in a pair of vectors. The type
guarantees that the vectors will contain only elements of type \texttt{Int},
and that the input lengths and the output length all correspond. A natural
question to ask here, which is typically neglected by introductory tutorials,
is ``How do I turn this into a program?'' That is, given some lists entered
by a user, how do we get into a position to be able to apply the 
\texttt{vadd} function? Before doing so, we will have to:

\begin{itemize}
\item Read user input, either from the keyboard, a file, or some other input device.
\item Check that the user inputs are valid, i.e. contain only \texttt{Int}s and
are the same length, and report an error if not.
\item Write output
\end{itemize}

The complete program will include side-effects for I/O and error handling,
before we can get to the pure core functionality. In this tutorial, we will
see how \Idris{} supports side-effects. Furthermore, we will see how we can 
use the dependent type system to \emph{reason} about stateful and
side-effecting programs. We will return to this specific example later.

\subsection{Hello world}

To give an idea of how programs with effects look in \Idris{}, here is the
ubiquitus ``Hello world'' program, written using the \effects{} library:

\begin{code}
module Main
  
import Effect.StdIO
  
hello : { [STDIO] } Eff IO ()
hello = putStrLn "Hello world!"
  
main : IO ()
main = run hello
\end{code}

\noindent
As usual, the entry point is \texttt{main}. All \texttt{main} has to do is
invoke the \texttt{hello} function which supports the \texttt{STDIO} effect
for console I/O, runs in the \texttt{IO} context, and returns the unit
value. The details of the \texttt{Eff} type will be presented in the
remainder of this tutorial.

To compile and run this program, \Idris{} needs to be told to include the
\effects{} package, using the \texttt{-p} \effects{} flag (this flag
is required for all examples in this tutorial):

%FIXME: \effects{} macro didn't work here, make sure to update it...
\begin{code}
$ idris hello.idr -o hello -p neweffects
$ ./hello
Hello world!
\end{code}

\subsection{Outline}

TODO: Lots of examples. We will have, roughly:

\begin{itemize}
\item Programming with state, multiple states and labelling.
\item Exceptions --- expression evaluator example
\begin{itemize}
\item Extend with random numbers, I/O for debugging.
\end{itemize}
\item Resource dependent effects
\begin{itemize}
\item File I/O
\item Dependent types in state
\end{itemize}
\item An imperative language with effects
\item Hangman, rules as a protocol
\item Space invaders overview?
\end{itemize}
